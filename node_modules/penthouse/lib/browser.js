'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.closeBrowserPage = exports.getOpenBrowserPage = exports.browserIsRunning = exports.restartBrowser = exports.closeBrowser = exports.launchBrowserIfNeeded = undefined;

let launchBrowserIfNeeded = exports.launchBrowserIfNeeded = (() => {
  var _ref = _asyncToGenerator(function* ({ getBrowser, width, height }) {
    if (browser) {
      return;
    }
    const usingCustomGetBrowser = getBrowser && typeof getBrowser === 'function';
    if (usingCustomGetBrowser && !_browserLaunchPromise) {
      debuglog('using browser provided via getBrowser option');
      _browserLaunchPromise = Promise.resolve(getBrowser());
    }
    if (!_browserLaunchPromise) {
      debuglog('no browser instance, launching new browser..');

      _browserLaunchPromise = _puppeteer2.default.launch({
        args: DEFAULT_PUPPETEER_LAUNCH_ARGS,
        ignoreHTTPSErrors: true,
        defaultViewport: {
          width,
          height
        }
      });
    }
    _browserLaunchPromise.then((() => {
      var _ref2 = _asyncToGenerator(function* (browser) {
        debuglog('browser ready');
        const browserPages = yield browser.pages();
        if (browserPages.length > 0) {
          debuglog('re-using the page browser launched with');
          browserPages.forEach(function (Page) {
            if (!reusableBrowserPages.includes(Page)) {
              Page.notSetupForPenthouse = true;
              reusableBrowserPages.push(Page);
            } else {
              debuglog('ignoring browser page already inside reusableBrowserPages');
            }
          });
        }
        return browser;
      });

      return function (_x2) {
        return _ref2.apply(this, arguments);
      };
    })());

    browser = yield _browserLaunchPromise;
    _browserLaunchPromise = null;
  });

  return function launchBrowserIfNeeded(_x) {
    return _ref.apply(this, arguments);
  };
})();

let closeBrowser = exports.closeBrowser = (() => {
  var _ref3 = _asyncToGenerator(function* ({ forceClose, unstableKeepBrowserAlive }) {
    if (browser && (forceClose || !unstableKeepBrowserAlive)) {
      if (ongoingJobs > 0) {
        debuglog('keeping browser open as ongoingJobs: ' + ongoingJobs);
      } else if (browser && browser.close) {
        browser.close();
        browser = null;
        _browserLaunchPromise = null;
        debuglog('closed browser');
      }
    }
  });

  return function closeBrowser(_x3) {
    return _ref3.apply(this, arguments);
  };
})();

let restartBrowser = exports.restartBrowser = (() => {
  var _ref4 = _asyncToGenerator(function* ({ getBrowser, width, height }) {
    let browserPages;
    if (browser) {
      browserPages = yield browser.pages();
    }
    debuglog('restartBrowser called' + browser && browserPages && '\n_browserPagesOpen: ' + browserPages.length);
    // for some reason Chromium is no longer opened;
    // perhaps it crashed
    if (_browserLaunchPromise) {
      // in this case the browser is already restarting
      yield _browserLaunchPromise;
      // if getBrowser is specified the user is managing the puppeteer browser themselves,
      // so we do nothing.
    } else if (!getBrowser) {
      console.log('now restarting chrome after crash');
      browser = null;
      yield launchBrowserIfNeeded({ width, height });
    }
  });

  return function restartBrowser(_x4) {
    return _ref4.apply(this, arguments);
  };
})();

let browserIsRunning = exports.browserIsRunning = (() => {
  var _ref5 = _asyncToGenerator(function* () {
    try {
      // will throw 'Not opened' error if browser is not running
      yield browser.version();
      return true;
    } catch (e) {
      return false;
    }
  });

  return function browserIsRunning() {
    return _ref5.apply(this, arguments);
  };
})();

let getOpenBrowserPage = exports.getOpenBrowserPage = (() => {
  var _ref6 = _asyncToGenerator(function* () {
    const browserPages = yield browser.pages();

    // if any re-usable pages to use, avoid unnecessary page open/close calls
    if (reusableBrowserPages.length > 0) {
      debuglog('re-using browser page for generateCriticalCss, remaining at: ' + browserPages.length);
      const reusedPage = reusableBrowserPages.pop();
      let reused = true;
      // if we haven't yet run any penthouse jobs with this page,
      // don't consider it reused - i.e. it will need to be configured.
      if (reusedPage.notSetupForPenthouse) {
        reused = false;
        // but only once
        delete reusedPage.notSetupForPenthouse;
      }
      return Promise.resolve({
        page: reusedPage,
        reused
      });
    }

    debuglog('adding browser page for generateCriticalCss, before adding was: ' + browserPages.length);
    return browser.newPage().then(function (page) {
      return { page };
    });
  });

  return function getOpenBrowserPage() {
    return _ref6.apply(this, arguments);
  };
})();

let closeBrowserPage = exports.closeBrowserPage = (() => {
  var _ref7 = _asyncToGenerator(function* ({
    page,
    error,
    unstableKeepBrowserAlive,
    unstableKeepOpenPages
  }) {
    if (!browser || !page) {
      return;
    }
    const browserPages = yield browser.pages();
    debuglog('remove (maybe) browser page for generateCriticalCss, before removing was: ' + browserPages.length);

    const badErrors = ['Target closed', 'Page crashed'];
    if (page && !(error && badErrors.some(function (badError) {
      return error.toString().indexOf(badError) > -1;
    }))) {
      // Without try/catch if error penthouse will crash if error here,
      // and wont restart properly
      try {
        // must await here, otherwise will receive errors if closing
        // browser before page is properly closed,
        // however in unstableKeepBrowserAlive browser is never closed by penthouse.
        if (unstableKeepBrowserAlive) {
          if (unstableKeepOpenPages !== 'all' && browserPages.length > unstableKeepOpenPages) {
            page.close();
          } else {
            debuglog('saving page for re-use, instead of closing');
            if (error) {
              // When a penthouse job execution errors,
              // in some conditions when later re-use the page
              // certain methods don't work,
              // such as Page.setUserAgent never resolving.
              // "resetting" the page by navigation to about:blank first fixes this.
              debuglog('Reset page first..');
              yield page.goto('about:blank').then(function () {
                debuglog('... page reset DONE');
              });
            }
            reusableBrowserPages.push(page);
          }
        } else {
          debuglog('now try to close browser page');
          yield page.close();
        }
      } catch (err) {
        debuglog('failed to close browser page (ignoring)');
      }
    }
  });

  return function closeBrowserPage(_x5) {
    return _ref7.apply(this, arguments);
  };
})();

exports.addJob = addJob;
exports.removeJob = removeJob;

var _puppeteer = require('puppeteer');

var _puppeteer2 = _interopRequireDefault(_puppeteer);

var _debug = require('debug');

var _debug2 = _interopRequireDefault(_debug);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _asyncToGenerator(fn) { return function () { var gen = fn.apply(this, arguments); return new Promise(function (resolve, reject) { function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { return Promise.resolve(value).then(function (value) { step("next", value); }, function (err) { step("throw", err); }); } } return step("next"); }); }; }

const debuglog = (0, _debug2.default)('penthouse:browser');

// shared between penthouse calls
let browser = null;
let _browserLaunchPromise = null;
let reusableBrowserPages = [];
// keep track of when we can close the browser penthouse uses;
// kept open by continuous use
let ongoingJobs = 0;
function addJob() {
  ongoingJobs = ongoingJobs + 1;
}
function removeJob() {
  ongoingJobs = ongoingJobs - 1;
}

const DEFAULT_PUPPETEER_LAUNCH_ARGS = ['--disable-setuid-sandbox', '--no-sandbox', '--ignore-certificate-errors'
// better for Docker:
// https://github.com/GoogleChrome/puppeteer/blob/master/docs/troubleshooting.md#tips
// (however caused memory leaks in Penthouse when testing in Ubuntu, hence disabled)
// '--disable-dev-shm-usage'
];